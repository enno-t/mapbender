# Elements

## Understanding elements

Elements are the building blocks of every application. Each element provides some functionality and can interact with other elements. The map element is probably the element you face most of the time as it provides all map viewing capabilities.

Each element consists of four parts itself:

* PHP class: Describes the element with it's capabilities and also can provide an Ajax callback point, so that the client-side widget can execute database queries display the result.
* Twig Template: HTML the element is using. In the most basic version, this would just be a DIV, but it can be as complex as is needed.
* JavaScript Widget: this is the client side part of an element. It is everything you do and interact with on your screen. Using Ajax, it can call its server-side counterpart to do things like database queries.
* CSS: Most elements want some style, so they may provide their own.

### Twig Template

Every element must have an HTML element it is represented by. In the most basic case, this can be a simple `<div>` element, but this can be complex as needed.

For HTML generation, Mapbender uses [Twig](https://twig.symfony.com/). A minimal twig template for an element would like this:

```html
<div id="{{ id }}" class="mb-element mb-element-myclass"></div>
```

As you can see, you need to set the ID (generated by Mapbender) as well as the general `mb-element` class and a class specifically for your element.

### JavaScript Widgets

Element widgets are build using the [jQuery UI widget factory](https://wiki.jqueryui.com/w/page/12138135/Widget%20factory). This ensures a common pattern for widget development and offers

* default options
* constructors and (optional) destructors
* private and public methods

The basic skeleton looks like this:

```javascript
    (function($) {

    // This is the widget factory. It will create an widget class "mbMyClass" in the jQuery object as well as an
    // "mbMyClass" object in the "mapbender" namespace in the jQuery object (they are used differently). Be sure
    // to use the "mb" prefix for your widget name as not to overwrite existing jQuery functions.
    $.widget('mapbender.mbMyClass', {
        // This sets up the default options which can be overriden in the Mapbender configuration.
        // This will be moved into the PHP class at a later point.
        // The final options object can be accessed as "this.options".
        options: {
            foo:    'bar',
            answer: 42
        },

        // This attribute is private for your widget.
        var1: null,

        // Constructor, gets called on widget initialization.
        _create: function() {
            // Do everything needed for set up here, for example event handling
            this.element.bind('mbmyclassmagicdone', $.proxy(this._onMagicDone, this));
            this.element.bind('click', $.proxy(this._clickCallback, this));
        },

        // Destructore, here set to the jQuery empty function
        destroy: $.noop,

        // Public function, callable like "$('#element-13').mbMyClass('methodA', parameterA, parameterB)"
        methodA: function(parameterA, parameterB) {
            this._methodB(parameterA);
        },

        // Private function, only callable from within this widget
        _methodB: function(parameterA) {
            // The triggered signal will be named "mbmyclassmagicdone" (all lowercase)
            this._trigger('magicdone');
        },

        _onMagicDone: function() {
            alert("Oh, magic!");
        },

        _clickCallback: function(event) {
            var target = $(event.target);
            var id = target.attr('id');
            // ...
        }

    });

    })(jQuery);
```

For event handling, jQuery.proxy is your friend to ensure that the callback is guaranteed to be executed in the right context:

```javascript
    // ...

    this.element.click($.proxy(this._clickCallback, this));

    // ...
```

This way, `this` inside the clickCallback method is the this given as the second parameter here (usually the widget instance) and not the HTML element which triggered the event. To access the HTML event, use the target property of the event passed as the argument to the clickCallback method.

## Element to Element communication

There's an active and a passive way to communicate with another widget. The active way is to call a public method of the other widget. For that, you have to select the widget's HTML element with jQuery and call the method like this:

```javascript
    var otherElement = $('#element-13').mbMyClass('methodA', parameterA, parameterB);
```

This is standard jQuery UI stuff and pretty much self-explanatory. The more tricky question is how do you know the other's HTML element? As you can see, using the ID to select the element is preferred, but these IDs are generated on the fly by Mapbender when the application is started, so you can't assume that the ID is the always the same.
Luckily you can pass an element ID in the configuration as the target options for an Element. This will be replaced with the run-time ID of that target Elements' HTML element for you, so that in your widget code you can access the right ID as `this.options.target`.

```javascript
    $('#' + this.options.target).mbMyClass('methodA', parameterA, parameterB);

```

The passive way for communication is to subscribe to events of another target. You also need to know the HTML element,
but you can now listen for the other widget to call your widget. This is done using default jQuery events. <!--Well, almost
default jQuery events: If you use the "_trigger" method provided by the jQuery UI widget factory-->

## How to create your own Element?

Mapbender offers an app/console command to create different elements:

* general elements
* buttons
* elements for map-click events
* elements for map-box events

> [!TIP]
> The new generated element contains only a skeleton and has to be modified after generation.

The following example show the generation and modification of a map-click element.

## The steps to create your own Element

There are some steps you have to follow on the way to your own element.

* create your own bundle
* create an element via *app/console*
* edit your new element for your needs
* add the new element to the function *getElements()* to make it available from the backend

### Use app/console to generate your own bundle

Find out more about the command with help:

```console
 app/console generate:bundle --help
```

```console
 app/console generate:bundle --namespace=Workshop/DemoBundle --dir=src
```

You have to answer some questions before the element will be created:

```console
 Bundle name [WorkshopDemoBundle]: WorkshopDemoBundle
 
 Determine the format to use for the generated configuration. 
 Configuration format (yml, xml, php, or annotation): annotation

 To help you get started faster, the command can generate some code snippets for you.

 Do you want to generate the whole directory structure [no]? yes
 
 Summary before generation  
 You are going to generate a "Workshop\DemoBundle\WorkshopDemoBundle" bundle in "src/" using the "annotation" format.
 
 Do you confirm generation [yes]? yes
 
 Confirm automatic update of your Kernel [yes]? yes
 
 Confirm automatic update of the Routing [yes]? yes
```

After these steps, your new bundle is available at `src`. The bundle is already registered in the file *AppKernel.php*. In *routing.yml*, you will find a new entry for the bundle.

### Use app/console to generate a new element

Find out more about the command with help:

```console
 app/console mapbender:generate:element --help
```

Generate a new element with the following command:

```console
 app/console mapbender:generate:element --type "map-click" "Workshop\DemoBundle" MapKlick src
```

You will get a summary of actions

```console
 Summary of actions
 - Your element WorkshopDemoBundle\Element\MapKlick has been created.
 - The following files have been created:
  - PHP class (src/Workshop/DemoBundle/Element/MapKlick.php)
  - jQuery widget (src/Workshop/DemoBundle/Resources/public/mapbender.element.mapklick.js)
```

## Edit your new element for your needs

### Change the title and description in the php file

You will find several functions in the php file. Change the return value of the functions *getClassTitle()* and *getClassDescription()*.

```console
    public static function getClassTitle() {
        return "MapKlick";
    }
```

```console
    public static functionpython
This will make the element available in the backend when you configure your application.
```

```php
 <?php
 
 namespace Workshop\DemoBundle; 
 
 use Symfony\Component\HttpKernel\Bundle\Bundle;
 use Mapbender\CoreBundle\Component\MapbenderBundle;
 
 class WorkshopDemoBundle extends MapbenderBundle
 {
     public function getElements()
     {
         return array(
             'Workshop\DemoBundle\Element\MapKlick'   
         );
     }
 }
```

## Add the new element to an application

Create a new application and add your element to the new application.
Note that the configuration for your generated element is done in YAML syntax. If you want to use the map element as target you have to find out its ID (e.g. via the browser Inspector tool).

## Change the action on Click event

When you generate a map-click element, you get an event on click and an action. The action can be modified. Have a look in the JQuery widget file (*mapbender/src/Workshop/DemoBundle/Resources/public/mapbender.element.mapklick.js*).

You will find the function *_mapClickHandler()* that determines the coordinates from the click event and passes them to the function *_mapClickWorker()*. The new generated element will show the coordinates of the click event in an alert box.

You can modify the action of the function *_mapClickWorker()*.

## Default definition of _mapClickWorker()

```javascript
 _mapClickWorker: function(coordinates) {
        alert('You clicked: ' +
                coordinates.pixel.x + ' x ' + coordinates.pixel.y +
                ' (Pixel), which equals ' +
                coordinates.world.x + ' x ' + coordinates.world.y +
                ' (World).');
    }
```

## modified _mapClickWorker() opens OpenStreetMap

Alternatively, you could open a new window with an URL and add the coordinates as parameters. You can open OpenStreetMap and center to the coordinates of the click event.

<https://www.openstreetmap.org/export#map=15/50.7311/7.0985>
  
```javascript
 _mapClickWorker: function(coordinates) {
        window.open('https://www.openstreetmap.org/export#map=15/' + coordinates.world.y + '/' + coordinates.world.x);
    }
```

[↑ Back to top](#elements)

[← Back to README](../README.md)
